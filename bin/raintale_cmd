#!python

import sys
import os
import argparse
import logging
import json
import errno

from urllib.parse import urlparse
from argparse import RawTextHelpFormatter

import requests

from yaml import load, Loader

from raintale.storytellers import storytellers, storytelling_services
from raintale.storygenerators import storygenerators

logger = logging.getLogger(__name__)

def get_logger(appname, loglevel, logfile):

    logger = logging.getLogger(appname)

    if logfile == sys.stdout:
        logging.basicConfig( 
            format='%(asctime)s [%(levelname)s] %(name)s: %(message)s',
            level=loglevel)
    else:
        logging.basicConfig( 
            format='%(asctime)s [%(levelname)s] %(name)s: %(message)s',
            level=loglevel,
            filename=logfile)

    return logger

def calculate_loglevel(verbose=False, quiet=False):
  
    # verbose trumps quiet
    if verbose:
        return logging.DEBUG

    if quiet:
        return logging.WARNING

    return logging.INFO

def process_arguments(args):

    parser = argparse.ArgumentParser(prog="{}".format(args[0]),
        description='Given a list of story elements, including URLs to archived web pages, raintale publishes them to the specified service.',
        formatter_class=RawTextHelpFormatter
        )

    parser.add_argument('-i', '--input', dest='input_filename',
        required=True,
        help="An input file containing the memento URLs for use in the story."
    )

    parser.add_argument('--storyteller', dest='storyteller',
        required=True,
        help="""The service used to tell the story. Options are:
        * rawhtml - write raw HTML output to a file, requires -o option to specify the filename
        * twitter - publish tweets containing story data, requries -c option to specify the credentials file
        """
    )

    parser.add_argument('--storyformat', dest='storyformat',
        required=False, default="socialcard",
        help="""The type of surrogate to use for the story. Outputs are:
        * socialcard - a social card used by most social media platforms
        Note: the specified storyteller will use this format in different ways.
        """
    )

    parser.add_argument('--title', dest='title',
        required=True,
        help="The title used for the story."
    )

    parser.add_argument('--collection-url', dest='collection_url',
        required=False,
        help="The URL of the collection from which the story is derived."
    )

    parser.add_argument('--generated-by', dest='generated_by',
        required=False,
        help="The name of the algorithm or person who created this story."
    )

    parser.add_argument('--mementoembed_api', dest='mementoembed_api',
        required=False, 
        default=["http://localhost:5550", "http://mementoembed:5550"],
        help="The URL of the MementoEmbed instance used for generating surrogates"
    )

    parser.add_argument('-l', '--logfile', dest='logfile',
        default=sys.stdout,
        help="If specified, logging output will be written to this file. "
            "Otherwise, it will print to the screen."
    )

    parser.add_argument('-c', '--credentials_file', dest='credentials_file',
        required=False, default=None,
        help="The file containing the credentials needed to use a storytelling service, in YAML format."
    )

    parser.add_argument('-v', '--verbose', dest='verbose',
        action='store_true',
        help="This will raise the logging level to debug for more verbose output")

    parser.add_argument('-q', '--quiet', dest='quiet',
        action='store_true',
        help="This will lower the logging level to only show warnings or errors")

    parser.add_argument('-o', '--output-file', dest='output_file',
        required=False, default=None,
        help="If needed by the storyteller, the output file to which raintale will write the story contents."
    )

    args = parser.parse_args()

    if args.storyteller in storytelling_services:
        if args.credentials_file is None:
            parser.error(
                "storyteller of type {} requires a credentials file, please supply a credentials file with the -c option".format(args.storyteller)
            )
    else:
        if args.output_file is None:
            parser.error(
                'storyteller of type {} requires an output file, please supply an output file with the -o option'.format(args.storyteller)
            )

    return args

def test_mementoembed_endpoint(url):

    status = False

    logger.info("testing MementoEmbed endpoint at {}".format(url))

    try:
        requests.get(url)
        status = True
    except requests.ConnectionError:
        logger.error("Failed to connect to MementoEmbed endpoint at {}".format(url))

    return status

def gather_credentials(storyteller, credentials_file, output_filename):

    credentials_json = {}

    if credentials_file is None:

        if output_filename is not None:
            credentials_json = {
                "output_filename": output_filename
            }
        else:
            logger.error("No credentials and no output file. Cannot continue...")
            sys.exit(errno.EINVAL)
    else:
        
        with open(credentials_file) as f:
            credentials_json = load(f, Loader=Loader)

    return credentials_json

def format_data(input_filename, title, collection_url, generated_by):

    story_data = {}

    logger.info("reading story data from file {}".format(input_filename))

    with open(input_filename) as f:

        try:
            story_data = json.load(f)

        except json.JSONDecodeError:

            logger.warning("story data is not JSON, attempting to read as "
                "a list of memento URLs in a text file")

            f.seek(0)
            story_data['title'] = title
            
            # if collection_url is not None:
            #     logger.debug("storing given collection URL of {}".format(collection_url))
            story_data['collection_url'] = collection_url

            # if generated_by is not None:
            #     logger.debug("storing generated by value of {}".format(generated_by))
            story_data['generated_by'] = generated_by

            story_data['elements'] = []

            logger.info("set story title to {}".format(
                story_data['title']
            ))

            logger.info("creating story elements")

            for line in f:

                line = line.strip()
                o = urlparse(line)

                if o.scheme in ['http', 'https']:

                    logger.debug("adding link {} to story".format(line))

                    element = {
                        'type': 'link',
                        'value': line
                    }

                    story_data['elements'].append(element)

                else:
                    logger.warning(
                        "Skipping URL with unsupported scheme: {}".format(line)
                    )

            logger.warning("list of memento URLs has been built successfully")

    return story_data

def tell_story(storyteller, storyformat, story_data, mementoembed_api, 
    credentials):

    if type(mementoembed_api) == list:
        statusii = []
        for url in mementoembed_api:
            status = test_mementoembed_endpoint(url)
            statusii.append(status)

            if status == True:
                logger.info("Successfully connected to MementoEmbed API at {}, using this endpoint".format(url))
                mementoembed_api = url
                break

        if True not in statusii:
            logger.error("Failed to connect to MementoEmbed API, cannot continue.")
            sys.exit(errno.EHOSTDOWN)
        
    else:
        status = test_mementoembed_endpoint(mementoembed_api)

        if status == False:
            logger.error("Failed to connect to MementoEmbed API, cannot continue.")
            sys.exit(errno.EHOSTDOWN)

    logger.info("For building story elements, using MementoEmbedAPI at {}".format(mementoembed_api))

    logger.info("building story with storyteller {} and format {}".format(
        storyteller, storyformat
    ))

    if storyteller not in storytelling_services:
        storyformat = "rawhtml_{}".format(storyformat)
        storyteller = "rawhtml"

    if storyteller == "blogger":
        storyformat = "rawhtml_{}".format(storyformat)

    sg = storygenerators[storyformat](mementoembed_api)
    st = storytellers[storyteller](sg, story_data, credentials)
    st.tell_story()

    return story_data

if __name__ == '__main__':

    args = process_arguments(sys.argv)

    # set up logging for the rest of the system
    logger = get_logger(
        __name__, calculate_loglevel(
            verbose=args.verbose, quiet=args.quiet), 
        args.logfile)

    logger.info("Beginning raintale to tell your story.")

    credentials = gather_credentials(args.storyteller, args.credentials_file, args.output_file)

    story_data = format_data(args.input_filename, args.title, args.collection_url, args.generated_by)

    story_output = tell_story(
        args.storyteller,
        args.storyformat,
        story_data,
        args.mementoembed_api,
        credentials
    )

    logger.info("Done telling your story. Output is now at {}.".format(args.storyteller))
