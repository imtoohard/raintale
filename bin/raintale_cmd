#!python

import sys
import os
import argparse
import logging
import json
import errno

from urllib.parse import urlparse
from argparse import RawTextHelpFormatter

import requests

from yaml import load, Loader

from raintale.storytellers import storytellers, storytelling_services
from raintale.storygenerators import storygenerators, StoryGenerator
from raintale import package_directory

logger = logging.getLogger(__name__)

def get_logger(appname, loglevel, logfile):

    logger = logging.getLogger(appname)

    if logfile == sys.stdout:
        logging.basicConfig( 
            format='%(asctime)s [%(levelname)s] %(name)s: %(message)s',
            level=loglevel)
    else:
        logging.basicConfig( 
            format='%(asctime)s [%(levelname)s] %(name)s: %(message)s',
            level=loglevel,
            filename=logfile)

    return logger

def calculate_loglevel(verbose=False, quiet=False):
  
    # verbose trumps quiet
    if verbose:
        return logging.DEBUG

    if quiet:
        return logging.WARNING

    return logging.INFO

def generate_list_of_storytellers_and_presets():

    storytellers = []
    presets = []

    template_dir = "{}/templates".format(package_directory)

    for filename in os.listdir(template_dir):

        preset, fileformat = filename.split('.')
        storytellers.append(fileformat)
        presets.append(preset)

    return storytellers, presets

def process_arguments(args):

    parser = argparse.ArgumentParser(prog="{}".format(args[0]),
        description='Given a list of story elements, including URLs to archived web pages, raintale publishes them to the specified service.',
        formatter_class=RawTextHelpFormatter
        )

    parser.add_argument('-i', '--input', dest='input_filename',
        required=True,
        help="An input file containing the memento URLs for use in the story."
    )

    storytellers, presets = generate_list_of_storytellers_and_presets()

    formatted_storytellers_list = ""
    for storyteller in storytellers:
        formatted_storytellers_list += "* {} - requires -o option to specify the output file\n\t".format(storyteller)

    formatted_preset_list = ""
    for preset in list(set(presets)):
        formatted_preset_list += "* {}\n\t".format(preset)

    parser.add_argument('--storyteller', dest='storyteller',
        required=True,
        help="""The service or file format used to tell the story. Options are:
        * twitter - publish tweets containing story data, requries -c option to specify the credentials file
        {}
        """.format(formatted_storytellers_list)
    )

    parser.add_argument('--preset', dest='storytelling_preset',
        required=False, default='socialcard',
        help="""The preset used for a given story, typically reflecting the 
        surrogate used to tell the story and the layout of the story.
        {}
        """.format(formatted_preset_list)
    )

    parser.add_argument('--story-template', dest='story_template',
        required=False,
        help="The file containing the template for the story in Jinja2 format."
    )

    parser.add_argument('--title', dest='title',
        required=True,
        help="The title used for the story."
    )

    parser.add_argument('--collection-url', dest='collection_url',
        required=False,
        help="The URL of the collection from which the story is derived."
    )

    parser.add_argument('--generated-by', dest='generated_by',
        required=False,
        help="The name of the algorithm or person who created this story."
    )

    parser.add_argument('--mementoembed_api', dest='mementoembed_api',
        required=False, 
        default=["http://localhost:5550", "http://mementoembed:5550"],
        help="The URL of the MementoEmbed instance used for generating surrogates"
    )

    parser.add_argument('-l', '--logfile', dest='logfile',
        default=sys.stdout,
        help="If specified, logging output will be written to this file. "
            "Otherwise, it will print to the screen."
    )

    parser.add_argument('-c', '--credentials_file', dest='credentials_file',
        required=False, default=None,
        help="The file containing the credentials needed to use a storytelling service, in YAML format."
    )

    parser.add_argument('-v', '--verbose', dest='verbose',
        action='store_true',
        help="This will raise the logging level to debug for more verbose output")

    parser.add_argument('-q', '--quiet', dest='quiet',
        action='store_true',
        help="This will lower the logging level to only show warnings or errors")

    parser.add_argument('-o', '--output-file', dest='output_file',
        required=False, default=None,
        help="If needed by the storyteller, the output file to which raintale will write the story contents."
    )

    args = parser.parse_args()

    if args.storyteller in storytelling_services:
        if args.credentials_file is None:
            parser.error(
                "storyteller of type {} requires a credentials file, please supply a credentials file with the -c option".format(args.storyteller)
            )
    else:
        if args.output_file is None:
            parser.error(
                'storyteller of type {} requires an output file, please supply an output file with the -o option'.format(args.storyteller)
            )

        if args.storyteller == 'template':
            if args.story_template is None:
                parser.error(
                    "storyteller of type {} requires a story template file, please supply a story template file with the --story-template option".format(args.storyteller)
                )

    return args

def test_mementoembed_endpoint(url):

    status = False

    logger.info("testing MementoEmbed endpoint at {}".format(url))

    try:
        requests.get(url)
        status = True
    except requests.ConnectionError:
        logger.error("Failed to connect to MementoEmbed endpoint at {}".format(url))

    return status

def gather_storyteller_data(args):

    storyteller_data = {}

    # Use the storytelling service, even if they specify a template
    if args.storyteller in storytelling_services:

        with open(args.credentials_file) as f:
            storyteller_data = load(f, Loader=Loader)

    else:

        # Use the template, even if they specify another storyteller
        if args.story_template is not None:

            storyteller_data['story_template'] = args.story_template
            storyteller_data['output_filename'] = args.output_file
            args.storyteller = 'template'

        else:

            template_dir = "{}/templates".format(package_directory)

            for filename in os.listdir(template_dir):

                preset, fileformat = filename.split('.')

                if fileformat == args.storyteller and preset == args.storytelling_preset:
                    args.storyteller = 'template'
                    storyteller_data['story_template'] = "{}/{}".format(template_dir, filename)
                    storyteller_data['output_filename'] = args.output_file
                    break
            
            if 'story_template' not in storyteller_data:
                logger.error("There are no storytellers of type {} with a preset of {} available, cannot continue".format(
                    args.storyteller, args.storytelling_preset
                ))
                sys.exit(errno.EINVAL)

    return storyteller_data

def format_data(input_filename, title, collection_url, generated_by):

    story_data = {}

    logger.info("reading story data from file {}".format(input_filename))

    with open(input_filename) as f:

        try:
            story_data = json.load(f)

        except json.JSONDecodeError:

            logger.warning("story data is not JSON, attempting to read as "
                "a list of memento URLs in a text file")

            f.seek(0)
            story_data['title'] = title
            
            # if collection_url is not None:
            #     logger.debug("storing given collection URL of {}".format(collection_url))
            story_data['collection_url'] = collection_url

            # if generated_by is not None:
            #     logger.debug("storing generated by value of {}".format(generated_by))
            story_data['generated_by'] = generated_by

            story_data['elements'] = []

            logger.info("set story title to {}".format(
                story_data['title']
            ))

            logger.info("creating story elements")

            for line in f:

                line = line.strip()
                o = urlparse(line)

                if o.scheme in ['http', 'https']:

                    logger.debug("adding link {} to story".format(line))

                    element = {
                        'type': 'link',
                        'value': line
                    }

                    story_data['elements'].append(element)

                else:
                    logger.warning(
                        "Skipping URL with unsupported scheme: {}".format(line)
                    )

            logger.warning("list of memento URLs has been built successfully")

    return story_data

def tell_story(storyteller, storyformat, story_data, mementoembed_api, 
    credentials):

    if type(mementoembed_api) == list:
        statusii = []
        for url in mementoembed_api:
            status = test_mementoembed_endpoint(url)
            statusii.append(status)

            if status == True:
                logger.info("Successfully connected to MementoEmbed API at {}, using this endpoint".format(url))
                mementoembed_api = url
                break

        if True not in statusii:
            logger.error("Failed to connect to MementoEmbed API, cannot continue.")
            sys.exit(errno.EHOSTDOWN)
        
    else:
        status = test_mementoembed_endpoint(mementoembed_api)

        if status == False:
            logger.error("Failed to connect to MementoEmbed API, cannot continue.")
            sys.exit(errno.EHOSTDOWN)

    logger.info("For building story elements, using MementoEmbedAPI at {}".format(mementoembed_api))

    logger.info("building story with storyteller {} and format {}".format(
        storyteller, storyformat
    ))

    if storyteller not in storytelling_services:

        if storyteller != 'template':
            storyformat = "rawhtml_{}".format(storyformat)
            storyteller = "rawhtml"

    if storyteller == "blogger":
        storyformat = "rawhtml_{}".format(storyformat)

    if storyteller == 'template':
        sg = StoryGenerator(mementoembed_api)
        st = storytellers[storyteller](sg, story_data, credentials)
    else:
        sg = storygenerators[storyformat](mementoembed_api)
        st = storytellers[storyteller](sg, story_data, credentials)        

    st.tell_story()

    return story_data

if __name__ == '__main__':

    args = process_arguments(sys.argv)

    # set up logging for the rest of the system
    logger = get_logger(
        __name__, calculate_loglevel(
            verbose=args.verbose, quiet=args.quiet), 
        args.logfile)

    logger.info("Beginning raintale to tell your story.")

    credentials = gather_storyteller_data(args)

    story_data = format_data(args.input_filename, args.title, args.collection_url, args.generated_by)

    story_output = tell_story(
        args.storyteller,
        "socialcard",
        story_data,
        args.mementoembed_api,
        credentials
    )

    if args.output_file is not None:
        logger.info("Done telling your story. Output is now at {}.".format(args.output_file))
    else:
        logger.info("Done telling your story. Output is now at {}.".format(args.storyteller))
